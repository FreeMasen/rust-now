<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Now is the Time</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Rust?</a></li><li><a href="chapter_2.0.html"><strong aria-hidden="true">2.</strong> How?</a></li><li><ol class="section"><li><a href="chapter_2.1.html"><strong aria-hidden="true">2.1.</strong> Mutability?</a></li><li><a href="chapter_2.2.html"><strong aria-hidden="true">2.2.</strong> Ownership and Borrowing</a></li><li><a href="chapter_2.3.html"><strong aria-hidden="true">2.3.</strong> Lifetimes?</a></li><li><a href="chapter_2.4.html"><strong aria-hidden="true">2.4.</strong> No Null?</a></li><li><a href="chapter_2.5.html"><strong aria-hidden="true">2.5.</strong> So?</a></li></ol></li><li><a href="chapter_3.0.html"><strong aria-hidden="true">3.</strong> Why Now</a></li><li><a href="chapter_4.0.html"><strong aria-hidden="true">4.</strong> Other Niceties</a></li><li><ol class="section"><li><a href="chapter_4.1.html"><strong aria-hidden="true">4.1.</strong> Arithmetic Data Types</a></li><li><a href="chapter_4.2.html"><strong aria-hidden="true">4.2.</strong> Pattern Matching</a></li><li><a href="chapter_4.3.html"><strong aria-hidden="true">4.3.</strong> Error Handling</a></li><li><a href="chapter_4.4.html"><strong aria-hidden="true">4.4.</strong> User Defined Types</a></li><li><a href="chapter_4.5.html"><strong aria-hidden="true">4.5.</strong> Traits</a></li><li><a href="chapter_4.6.html"><strong aria-hidden="true">4.6.</strong> Macros</a></li><li><a href="chapter_4.7.html"><strong aria-hidden="true">4.7.</strong> Tests</a></li></ol></li><li><a href="chapter_5.0.html"><strong aria-hidden="true">5.</strong> Getting Started</a></li><li><ol class="section"><li><a href="chapter_5.1.html"><strong aria-hidden="true">5.1.</strong> Rustup</a></li><li><a href="chapter_5.2.html"><strong aria-hidden="true">5.2.</strong> Cargo</a></li><li><a href="chapter_5.3.html"><strong aria-hidden="true">5.3.</strong> Bin vs Lib</a></li><li><a href="chapter_5.4.html"><strong aria-hidden="true">5.4.</strong> Std Types</a></li><li><a href="chapter_5.5.html"><strong aria-hidden="true">5.5.</strong> Resources</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Now is the Time</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#rust" id="rust">Rust?</a></h1>
<!--slides-only-->
<ul>
<li><em>Systems</em> Programming Language</li>
<li>Developed at Mozilla Research</li>
<li>Compiled/No Runtime</li>
<li>Memory Safe</li>
<li>No Data Races</li>
<li><em>Safe</em> Concurrency First</li>
</ul>
<!--slides-only-end-->
<!--web-only-->
<p>For the uninitiated Rust is a <em>systems</em> programming language from Mozilla designed with the goal of parallelizing the browser and was <a href="https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/">actually successful</a> in doing so. It is an attempt to balance the niceties of modern programming languages with the speed of C or C++. To achieve this, the output is fully compiled to machine code instead of an intermediate language and while this means that programs need to be compiled for a specific system, the range of systems is extremely broad. Current <em>tier 1</em> targets include MacOS, Windows and Linux (all for i686 and x86_64), <em>tier 2</em> targets include almost any system you can think of. If all of that wasn't already impressive, it is also <em>memory safe</em> meaning we don't have to worry about our program's memory the compiler will guarantee we aren't doing anything dangerous. So now the big question is how?</p>
<!--web-only-end-->
<!--notes
- Parallelizing the browser
- Successful with Quantum Css Engine
- Partial Web Renderer
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#how" id="how">How?</a></h1>
<!--web-only-->
<p>There are a few things that enable rust to deliver on its promises. The three we are going to cover in this section are mutability being at the type level, lifetimes and the borrow checker. Each of these play an important role individually but together they form a sort of safety Voltron. </p>
<!--web-only-end-->
<ul>
<li>Mutability at the type level</li>
<li>Ownership &amp; Borrowing</li>
<li>Lifetimes</li>
<li>No Nulls</li>
</ul>
<img id="voltron" src="./assets/img/voltron.jpg" height="400" alt="Voltron Assemble" style="display:none;margin-left: 10px;" />
<script>
    (function() {
        let v = document.getElementById('voltron');
        if (!v) return console.error('no voltron image found');
        setTimeout(() => {
            v.style.display = 'block'
        }, 5000);
    })();
</script>
<!--notes
- Overall reducing Runtime Errors
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#mutability" id="mutability">Mutability?</a></h1>
<!--web-only-->
<p>If you've ever learned a functional programming language this will probably be something you are familiar with, if not it can be a bit jarring. Any variable has a type and also a flag as to whether or not it can be changed. Consider these two examples, the first will not compile while the second will. The key here is the <code>mut</code> keyword, which declares something as mutable. It may seem small and unimportant but it will play a huge role as we move forward.</p>
<!--web-only-end-->
<pre><pre class="playpen"><code class="language-rust"># fn main() {
    let x = 0;
    // Nope!
    x += 1;
# }
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust"># fn main() {
    let mut x = 0;
    // YES!
    x += 1;
    println!(&quot;HAHA Success {}&quot;, x);
# }
</code></pre></pre>
<!--notes
- Could be familiar for Functional Programmers
- Example 1 will not compile
  - x is not declared as mutable
- Example 2 will compile
  - x is declared as mutable
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#ownership-and-borrowing" id="ownership-and-borrowing">Ownership and Borrowing?</a></h1>
<!--web-only-->
<p>The next thing to cover is how rust handles references. In some languages, the reference vs value is something the developer has almost no control over. In Rust, like in C or C++ the control of a reference vs value is explicitly provided by the developer. Consider the following</p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#owned-data-can-loan-that-data-out" id="owned-data-can-loan-that-data-out">Owned data can loan that data out</a></h3>
<p>This example borrows <code>&quot;ex&quot;</code> as <code>y</code></p>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust"># fn main() {
    let x = String::from(&quot;ex&quot;);;
    let y = &amp;x;
    println!(&quot;x: {}, y: {}&quot;, x, y); 
# }
</code></pre></pre>
<!--notes
Example 1
- x is a string
- y is borrowing "ex" from x
-->
<!--web-only-->
<p>In the above, we have two variables, <code>x</code> and <code>y</code>, <code>x</code> owns the value &quot;ex&quot; and <code>y</code> borrows the value of <code>x</code>. The console will print <code>x: 0, y: 0</code>. If we remove the <code>&amp;</code> from line 2 above, the compiler says no.</p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#loaning-data-is-explicit" id="loaning-data-is-explicit">Loaning data is explicit</a></h3>
<p>this example moves <code>String::from(&quot;ex&quot;)</code> into <code>y</code></p>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust"># fn main() {
    let x = String::from(&quot;ex&quot;);
    let y = x;
    println!(&quot;x: {}, y: {}&quot;, x, y);
# }
</code></pre></pre>
<!--notes
Example 2
- "ex" is moved from x into y
  - x is dead
-->
<!--web-only-->
<p>Our friendly complier tells us that we are trying to use a previously moved value, what does that mean? Well, in rust when we assign one variable to another we <em>move</em> the data into that new variable. In the above <code>x</code> owns the String &quot;ex&quot; on line 1, then on line 2 we move it into <code>y</code> so at that point <code>y</code> owns 0, when we try to look inside of <code>x</code> on line 3, we would find it empty because that value was moved. Here is the first rule of ownership and borrowing we need to know: any piece of data can only have 1 owner, that owner can lend out a reference to the data but the owner remains the same.</p>
<p>When we pair this concept with the explicitly mutable declaration we start to see the full picture of what is going on. Consider this example.
$web-only-end</p>
<!--slides-only-->
<h3><a class="header" href="#loaning-data-mutably" id="loaning-data-mutably">Loaning data mutably</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust"># fn main() {
    let mut x = [0,1,2];
    let y = &amp;mut x;
    y[0] += 1;
    // Updated!
    println!(&quot;x: {}&quot;, x[0]);
# }
</code></pre></pre>
<!--notes
Example 3
- x is a mutable array
- y is a mutable reference to x
- x is updated through y
- ** Mutability is still explicit with references **
-->
<!--web-only-->
<p>As you can see we were able to manipulate x through our variable <code>y</code> as you would expect. The one big caveat here lies in the second rule of ownership and borrowing: any data owner is allowed to share data immutably as many times as they'd like but there can only ever be 1 mutable reference at at time. </p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#is-exclusive" id="is-exclusive">Is exclusive</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust"># fn main() {
    let mut x = [0,1,2];
    let y = &amp;mut x;
    let z = &amp;mut x;
    y[0] += 1;
    z[2] += 1;
    // Nope!
    println!(&quot;x: {}&quot;, x[0]);
# }
</code></pre></pre>
<!--notes
Example 4
- Reference rules
  - Any number of references
  - 1 and only 1 mutable reference
-->
<!--web-only-->
<p>In this example, the compiler is telling us that y has an exclusive borrow on x, so we can't loan it to <code>z</code> until <code>y</code> is done with it. </p>
<!--web-only-end-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#lifetimes" id="lifetimes">Lifetimes</a></h1>
<!--web-only-->
<p>Now the big question is how does the compiler determine when a piece of data or reference is valid? To achieve this every data type must also have its lifetime defined. With owned data, we don't have to do anything special but for references there is an additional type parameter that might need to be provided. Let's take our first example from the last page and explicitly add this notation.</p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#data-lives-a-finite-life" id="data-lives-a-finite-life">Data lives a finite life</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">fn main() { 
    let x = 0;
    let y = &amp;x;
    println!(&quot;x: {}, y: {}&quot;, x, y);
}
</code></pre></pre>
<!--notes
Example 1
- Blue ('b) line is the lifetime for all of main
- x lives for all of 'b
- Red ('a) is the lifetime of y
  - y is a reference to x
  - 'a cannot outlive 'b, ever
- Both 'a and 'b end at the end of main
-->
<!--web-only-->
<p>Above is the same example from before, this time with some notation on where the two lifetimes start and end. lifetime <code>'b</code> begins at the start of the <code>main</code> function while lifetime <code>'a</code> starts when <code>y</code> borrows <code>x</code>; both of these lifetimes end at the bottom of <code>main</code>. </p>
<p>In this example our lifetimes both fit nicely into the same package as lexical scope. Variables defined in a scope are only available in that scope or a child scope and variables cannot be accessed before they are declared. Rust's lifetimes are far more powerful than just the lexical scope, to expand on that let's look at this example.</p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#failing-type-inference" id="failing-type-inference">Failing type inference</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = &quot;🐕🐕🔔🔔🐕🔔🐕🔔🐕🔔🔔🐕🐕🐕&quot;;
    let s2 = &quot;🐕🐕🔔🔔🔔🔔🔔🔔🐕🔔🐕🔔&quot;;
    let trimmed = moar_cowbell(s1, s2);
    println!(&quot;{}&quot;, trimmed);
}

fn moar_cowbell(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {
    let ct1 = s1.chars().fold(0, |acc, c| if c == '🔔' {
        acc + 1
    } else {
        acc
    });
    let ct2 = s2.chars().fold(0, |acc, c| if c == '🔔' {
        acc + 1
    } else {
        acc
    });
    if ct1 &gt; ct2 {
        s1
    } else {
        s2
    }
}
</code></pre></pre>
<!--notes
Example 2
- Failing Example
- The compiler cannot detect the lifetime of the return &str
- It must be tied to the lifetime of s1 or s2
- The way we are calling it s1 and s2 have the same lifetime
  - But eventually this might change
-->
<!--web-only-->
<p>In this example, we have defined a function called <code>moar_cowbell</code> which takes two string references and returns the one that contains more bell emoji, unfortunately this will not compile. Rust is smart enough to figure out most lifetime requirements without them having to be explicitly defined, through type inference. This is a system where the compiler looks at all possible type annotations that could be applied and when there is only one, the developer doesn't have to provide one. Lifetimes are actually a kind of type definition, in this situation the lifetime of the return value could come from <code>s1</code> or it could come from <code>s2</code>, because there isn't just one, we will need to add a little more information.</p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#now-with-lifetime-annotations" id="now-with-lifetime-annotations">Now with lifetime annotations</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = &quot;🐕🐕🔔🔔🐕🔔🐕🔔🐕🔔🔔🐕🐕🐕&quot;;
    let s2 = &quot;🐕🐕🔔🔔🔔🔔🔔🔔🐕🔔🐕🔔&quot;;
    let trimmed = moar_cowbell(s1, s2);
    println!(&quot;{}&quot;, trimmed);
}

fn moar_cowbell&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {
    let ct1 = s1.chars().fold(0, |acc, c| if c == '🔔' {
        acc + 1
    } else {
        acc
    });
    let ct2 = s2.chars().fold(0, |acc, c| if c == '🔔' {
        acc + 1
    } else {
        acc
    });
    if ct1 &gt; ct2 {
        s1
    } else {
        s2
    }
}
</code></pre></pre>
<!--notes
Example 3
- Same as previous, now with lifetime annotations
- Lifetimes are provided like generic arguments
  - though with a '
-->
<!--web-only-->
<p>With this newly encoded lifetime information, the compiler now knows that <code>s1</code>, <code>s2</code> and the return value all need to live the same lifetime.</p>
<p>Because each piece of data not only has a type but also a known lifetime that means we don't need to call <code>malloc/free</code> and also we don't need to have a runtime garbage collector, the rust compiler is able to just insert any allocation/deallocation you will need.</p>
<p>This brings us to the next big win for Rust and that is Memory Safety, with the above scheme, you can never encounter a null pointer, perform a double free or leak memory due to a complicated object graph (I'm looking at you JavaScript). </p>
<!--web-only-end-->
<script type="text/javascript" src="assets/lifetimes.js"></script>
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#no-null" id="no-null">No Null</a></h1>
<!--web-only-->
<p>The last piece in this puzzle is that no variable is allowed to be uninitialized, this means that there is no null pointer.</p>
<!--web-only-end-->
<!--slides-only-->
<h4><a class="header" href="#not-allowed" id="not-allowed">Not allowed</a></h4>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: usize;
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<!--notes
Example 1
- This doesn't compile because x might not have a value
- The Option enum helps with this, which we will talk about later
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#so" id="so">So?</a></h1>
<!--web-only-->
<p>Let's review, because mutability is declarative, we can differentiate between mutable references and non-mutable references. Our borrowing rules require that only one place can mutate data at a time. Lifetimes ensure that our data is allocated and cleaned up correctly. Finally, no variable can ever be null. What does that all mean?</p>
<ul>
<li>Because we can only mutate data from one place, we can't have a data race.</li>
<li>Because each piece of data not only has a type but also a known lifetime that means we don't need to call <code>malloc/free</code> and also we don't need to have a runtime garbage collector.</li>
<li>Because no variable can be null we can't act on something that doesn't exist.</li>
</ul>
<p>This turns out to squash a ridiculous number of bugs.</p>
<!--web-only-end-->
<!--slides-only-->
<ul>
<li>No data races</li>
<li>Memory safe
<ul>
<li>No malloc/free</li>
<li>No double free</li>
<li>No memory leaks</li>
<li>No reference cycles</li>
<li>No garbage collector</li>
</ul>
</li>
<li>Never null</li>
</ul>
<!--slides-only-end-->
<!--notes
- No data races
  - You can't share references across threads if any of them will be mutated
  - To do so you can use something like a mutex or Atomic data structure
- Memory Safe
  - No manual management
  - No memory leaks
  - No garbage collector errors
    - Refernce cycles
    - Complicated Object Graphs (JS)
  - No null pointer error
- This offloads a lot of possible runtime errors to compile time
  - which is a win
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#why-now" id="why-now">Why Now?</a></h1>
<!--web-only-->
<p>If you have tried to learn rust in the past, you may have run into some friction around a few points. First is the old borrow checker, up until late last year the rust compiler could only use lexical scope to determine the life of any borrowed data, that meant we would have to jump through some hoops like this.</p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#non-lexical-lifetimes" id="non-lexical-lifetimes">Non-lexical lifetimes</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 1;
    let y = &amp;mut x;
    {
       *y += 1;
    }
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<!--web-only-->
<p>Previously the borrow checker wouldn't have been able to tell that <code>println!</code> would be able to safely print <code>x</code> because it was borrowed mutably by <code>y</code> so we would put the mutable borrow in its own scope. Thankfully non-lexical lifetimes save us from this rigamarole.</p>
<p>Next up is the ability to use the <code>dyn</code> and <code>impl</code> keyword to refer to data that conforms to a specific <code>trait</code> (rust's primary inheritance construct) in a far more convenient way. Previously it was not possible to use traits as return types unless they were first <code>Box</code>ed onto the heap, this lead to some extra run-time cost. </p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#dynimpl-trait" id="dynimpl-trait">dyn/impl trait</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">
fn main() {
    let boxed_fn = get_closure();
    let raw_fn = get_closure_better();
    println!(&quot;{}, {}&quot;, boxed_fn(10), raw_fn(7));
}

fn get_closure() -&gt; Box&lt;dyn Fn(usize) -&gt; usize&gt; {
    Box::new(|x| x * x)
}

fn get_closure_better() -&gt; impl Fn(usize) -&gt; usize {
    |x| x * x
}
</code></pre></pre>
<!--web-only-->
<p>While it might not seem like much, it is a pretty big performance win for this kind of code. Previously you would need to create a function pointer and allocate that function on the heap, this would lead to a v-table being crated and you could only call that function through the v-table now there is no heap allocation and also no v-table. Whoa... lots of jargon in that one, quickly and to the point it is a lot faster.</p>
<p>Now for the kicker, async/await has just started to stabilize, this is a huge win! Previously, to perform some asynchronous operation you would either need to spin up a thread manually and then create a channel to communicate across those threads which is cumbersome at best. </p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#thread--channel" id="thread--channel">thread + channel</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">use std::{
    thread::{
        spawn,
        sleep
    },
    sync::mpsc::{
        channel,
    },
    time::Duration,
};

fn main() {
    let (sender, receiver) = channel();
    let s1 = sender.clone();
    spawn(move || {
        let s = s1;
        for x in 0..10 {
            s.send(Some(x as isize)).unwrap();
            sleep(Duration::from_millis(50 * x));
        }
        s.send(None).unwrap();
    });
    let s2 = sender.clone();
    spawn(move || {
        sleep(Duration::from_millis(500));
        let s = s2;
        for y in (-10..0).rev() {
            s.send(Some(y)).unwrap();
            let sleep_inc = y.abs() as u64;
            sleep(Duration::from_millis(50 * sleep_inc));
        }
        s.send(None).unwrap();
    });
    let mut done = 0;
    while done &lt; 2 {
        match receiver.recv() {
            Ok(Some(m)) =&gt; println!(&quot;{}&quot;, m),
            Ok(None) =&gt; done += 1,
            _ =&gt; (),
        }
    }
}
</code></pre></pre>
<!--web-only-->
<p>The other option was to utilize this 3rd party library trait called <code>Future</code> the big problem here is that the type signature is so complicated that it is difficult to get everything right.</p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#futures" id="futures">Futures</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">use std::{
    time::Duration,
};

#[macro_use]
extern crate futures;
extern crate tokio;
use std::fmt;

use futures::{
    prelude::*,
    Stream,
};
use tokio::timer::Interval;
struct Counter {
    end: isize,
    idx: isize,
    inc: bool,
    interval: Interval,
}
impl Counter {
    fn new(min: isize, max: isize) -&gt; Self {
        Self {
            end: max,
            idx: min,
            inc: min &lt; max,
            interval: Interval::new_interval(Duration::from_millis(1)),
        }
    }
}
impl Stream for Counter {
    type Item = isize;
    type Error = ();
    fn poll(&amp;mut self) -&gt; Poll&lt;Option&lt;Self::Item&gt;, Self::Error&gt; {
        try_ready!(
            self.interval.poll()
                // The interval can fail if the Tokio runtime is unavailable.
                // In this example, the error is ignored.
                .map_err(|_| ())
        );
        let next_wait = self.idx.abs() as u64;
        self.interval = Interval::new_interval(
            Duration::from_millis(1 + next_wait * 10)
        );
        Ok(if self.inc {
            if self.idx &lt; self.end {
                self.idx += 1;
                Async::Ready(Some(self.idx))
            } else {
                Async::Ready(None)
            }
        } else {
            if self.idx &gt; self.end {
                self.idx -= 1;
                Async::Ready(Some(self.idx))
            } else {
                Async::Ready(None)
            }
        })
    }
}

pub struct DisplayCt&lt;T&gt; {
    stream: T,
}

impl&lt;T&gt; DisplayCt&lt;T&gt; {
    fn new(stream: T) -&gt; DisplayCt&lt;T&gt; {
        Self {
            stream,
        }
    }
}

impl&lt;T&gt; Future for DisplayCt&lt;T&gt;
where
    T: Stream,
    T::Item: fmt::Debug,
{
    type Item = ();
    type Error = T::Error;

    fn poll(&amp;mut self) -&gt; Poll&lt;(), Self::Error&gt; {
        
        loop {
            let value = match try_ready!(self.stream.poll()) {
                Some(value) =&gt; value,
                None =&gt; break,
            };

            println!(&quot;{:?}&quot;, value);
        }

        Ok(Async::Ready(()))
    }
}
fn main() {
    let ct1 = Counter::new(0, 10).map_err(|e| eprintln!(&quot;{:?}&quot;, e));
    let ct2 = Counter::new(0, -10).map_err(|e| eprintln!(&quot;{:?}&quot;, e));
    let d1 = DisplayCt::new(ct1);
    let d2 = DisplayCt::new(ct2);
    let joined = d1.join(d2);
    tokio::run(
        joined.and_then(|_| Ok(()))
    );
}
</code></pre></pre>
<!--web-only-->
<p>Just a short time ago, the <code>Future</code> trait was co-opted by the rust standard library, so that it could be coupled with the keywords async and await. Similar to how JavaScript co-opted the concept of Promises to work with its async/await syntax, rust will be able to abstract all the Future craziness into these keywords.</p>
<p>It is anticipated to look something like this.</p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#asyncawait" id="asyncawait">async/await</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let up = || {
    for i in 0..10 {
        println!(&quot;{}&quot;, i);
        yield;
    }
    return;
};
let down = || {
    for i in (-10..0).rev() {
        println!(&quot;{}&quot;, i);
        yield;
    }
    return;
};
let up_gen = from_generator(up);
let down_gen = from_generator(down);
up_gen.await;
down_gen.await;
#}</code></pre></pre>
<!--web-only-->
<p>Sadly, that last example wont run right now but the last major RFC for a true MVP was just slated for stabilization. Since rust runs on a 6 week release cycle, that means we are looking at fewer than 12 weeks before this is fully realized.</p>
<p>Rust has been going through a huge ergonomic push to make life easier, things like non-lexical lifetimes have already made the learning curve ease up a bit. With async/await even much more advanced programs won't cause a developers head to explode.</p>
<p>With that, let's take a quick glance at a few other features rust can boast about.</p>
<!--web-only-end-->
<!--notes
Big slide, here's the highlights
- The last 2 years have brought a bunch of ergonomic wins
  - if you have ever heard of "fighting the borrow checker" that era is pretty much over
    - NLL
- We are on the cusp of async/await
  - Future trait (poll method)
    - Community built
    - adopted in last major release
  - Plugable runtimes
- Other Highlights
  - Swappable memory allocator
    - huge for embedded
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#other-niceties" id="other-niceties">Other Niceties</a></h1>
<!--web-only-->
<p>In addition to the new stuff in the last slide, Rust has a bunch of other nice features. </p>
<!--web-only-end-->
<ul>
<li>Arithmetic Data Types</li>
<li>Pattern Matching</li>
<li>Error Handling</li>
<li>User Defined Types</li>
<li>Traits</li>
<li>Robust Macros</li>
<li>Built in testing framework</li>
</ul>
<!--notes
- Arithmetic Data Types
- Pattern Matching
- Error Handling
- User Defined Types
- Traits
- Robust Macros
- Built in testing framework
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#arithmetic-data-types" id="arithmetic-data-types">Arithmetic Data Types</a></h1>
<!--web-only-->
<p>While this feature might have a pretty intimidating name (I program so I don't need to do math), it is an extremely powerful tool. Sometimes referred to as <em>tagged unions</em> or <em>enums with associated data</em>, it is a way to explicitly define one datatype that might have a few different shapes. It looks something like this.</p>
<!--web-only-end-->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Join(String),
    Leave(String),
    Nick(String, String),
    Shout(String),
    Whisper {from: String, to: String, msg: String}
}
#}</code></pre></pre>
<!--web-only-->
<p>The above is an example of all of the different messages a chat system might need. <code>Join</code> and <code>Leave</code> would contain the username for the user joining or leaving, <code>Nick</code> would allow a user to change their username by providing the current and new values, <code>Shout</code> is a message everyone can see while <code>Whisper</code> is a private message between two users. </p>
<p>That in an of itself isn't very compelling but when you pair that with pattern matching, it becomes extremely useful. Let's fill out this example to include listing for messages.</p>
<!--web-only-end-->
<!--notes
- Arithmetic Data Types
    - Tagged Unions
    - Enums with Associated Data
- Another feature picked from functional languages
- A huge win for explicit dynamism
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#pattern-matching" id="pattern-matching">Pattern Matching</a></h1>
<pre><pre class="playpen"><code class="language-rust">enum Message {
    Join(String),
    Leave(String),
    Nick(String, String),
    Shout { from: String, msg: String},
    Whisper {from: String, to: String, msg: String},
}
fn main() {
    let messages = vec![
        Message::Join(String::from(&quot;person1&quot;)),
        Message::Join(String::from(&quot;person2&quot;)),
        Message::Join(String::from(&quot;person3&quot;)),
        Message::Nick(String::from(&quot;person2&quot;), String::from(&quot;JunkMaster3000&quot;)),
        Message::Shout { 
            from: String::from(&quot;JunkMaster3000&quot;), 
            msg: String::from(&quot;All Hail JunkMaster!&quot;)
        },
        Message::Whisper {
            from: String::from(&quot;person1&quot;),
            to: String::from(&quot;person3&quot;),
            msg: String::from(&quot;Whoa, that went in a different direction than I was expecting&quot;),
        },
        Message::Whisper {
            from: String::from(&quot;person3&quot;),
            to: String::from(&quot;person1&quot;),
            msg: String::from(&quot;lol, yeah JunkMaster is a little wild sometimes&quot;),
        },
        Message::Leave(String::from(&quot;person1&quot;)),
    ];
    for msg in messages {
        match msg {
            Message::Join(username) =&gt; {
                println!(&quot;{} has joined the chat&quot;, username);
            },
            Message::Leave(username) =&gt; {
                println!(&quot;{} has left the chat&quot;, username);
            },
            Message::Nick(from, to) =&gt; {
                println!(&quot;{} has changed their username to {}&quot;, from, to);
            },
            Message::Shout { from, msg } =&gt; {
                println!(&quot;{}: {}&quot;, from, msg);
            },
            Message::Whisper { from, to, msg } =&gt; {
                println!(&quot;secret message for {} from {}:&quot;, to, from);
                println!(&quot;    {}&quot;, msg);
            }
        }
    }
}
</code></pre></pre>
<!--web-only-->
<p>The above is a naive example of how a chat program might run. We have our dummy message buffer in the variable <code>messages</code>. We loop over each <code>msg</code> in that collection and depending on what kind of message it is we print a different message to the console. The final key that makes this so powerful is that pattern matching is exhaustive, meaning if you added a new message type to the <code>Message</code> enum the compiler won't let you build the application until you have handled it.</p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#pattern-matching-is-exhaustive" id="pattern-matching-is-exhaustive">Pattern Matching is Exhaustive</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">enum Message {
    Join(String),
    Leave(String),
    Nick(String, String),
    Shout { from: String, msg: String},
    Whisper {from: String, to: String, msg: String},
    Kick(String),
}
#fn main() {
#    let messages = vec![
#        Message::Join(String::from(&quot;person1&quot;)),
#        Message::Join(String::from(&quot;person2&quot;)),
#        Message::Join(String::from(&quot;person3&quot;)),
#        Message::Nick(String::from(&quot;person2&quot;), String::from(&quot;JunkMaster3000&quot;)),
#        Message::Shout { 
#            from: String::from(&quot;JunkMaster3000&quot;), 
#            msg: String::from(&quot;All Hail JunkMaster!&quot;)
#        },
#        Message::Whisper {
#            from: String::from(&quot;person1&quot;),
#            to: String::from(&quot;person3&quot;),
#            msg: String::from(&quot;Whoa, that went in a different direction than I was expecting&quot;),
#        },
#        Message::Whisper {
#            from: String::from(&quot;person3&quot;),
#            to: String::from(&quot;person1&quot;),
#            msg: String::from(&quot;lol, yeah JunkMaster is a little wild sometimes&quot;),
#        },
#        Message::Leave(String::from(&quot;person1&quot;)),
#    ];
#    for msg in messages {
//....
match msg {
    Message::Join(username) =&gt; {
        println!(&quot;{} has joined the chat&quot;, username);
    },
    Message::Leave(username) =&gt; {
        println!(&quot;{} has left the chat&quot;, username);
    },
    Message::Nick(from, to) =&gt; {
        println!(&quot;{} has changed their username to {}&quot;, from, to);
    },
    Message::Shout { from, msg } =&gt; {
        println!(&quot;{}: {}&quot;, from, msg);
    },
    Message::Whisper { from, to, msg } =&gt; {
        println!(&quot;secret message for {} from {}:&quot;, to, from);
        println!(&quot;    {}&quot;, msg);
    }
}
#    }
#}
</code></pre></pre>
<!--web-only-->
<p>This allows a developer to feel confident that something is going to just get lost. If you needed to add a catch all you can do that with the <code>_</code> case.</p>
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#wildcard-matches" id="wildcard-matches">Wildcard Matches</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">#enum Message {
#    Join(String),
#    Leave(String),
#    Nick(String, String),
#    Shout { from: String, msg: String},
#    Whisper {from: String, to: String, msg: String},
#    Kick(String),
#}
#fn main() {
#    let messages = vec![
#        Message::Join(String::from(&quot;person1&quot;)),
#        Message::Join(String::from(&quot;person2&quot;)),
#        Message::Join(String::from(&quot;person3&quot;)),
#        Message::Nick(String::from(&quot;person2&quot;), String::from(&quot;JunkMaster3000&quot;)),
#        Message::Shout { 
#            from: String::from(&quot;JunkMaster3000&quot;), 
#            msg: String::from(&quot;All Hail JunkMaster!&quot;)
#        },
#        Message::Whisper {
#            from: String::from(&quot;person1&quot;),
#            to: String::from(&quot;person1&quot;),
#            msg: String::from(&quot;Whoa, that went in a different direction than I was expecting&quot;),
#        },
#        Message::Whisper {
#            from: String::from(&quot;person3&quot;),
#            to: String::from(&quot;person1&quot;),
#            msg: String::from(&quot;lol, yeah JunkMaster is a little wild sometimes&quot;),
#        },
#        Message::Leave(String::from(&quot;person1&quot;)),
#    ];
#    for msg in messages {
//...
match msg {
    Message::Join(username) =&gt; {
        println!(&quot;{} has joined the chat&quot;, username);
    },
    Message::Leave(username) =&gt; {
        println!(&quot;{} has left the chat&quot;, username);
    },
    Message::Nick(from, to) =&gt; {
        println!(&quot;{} has changed their username to {}&quot;, from, to);
    },
    Message::Shout { from, msg } =&gt; {
        println!(&quot;{}: {}&quot;, from, msg);
    },
    Message::Whisper { from, to, msg } =&gt; {
        println!(&quot;secret message for {} from {}:&quot;, to, from);
        println!(&quot;    {}&quot;, msg);
    },
    _ =&gt; println!(&quot;Unknown message&quot;),
}
#    }
#}
</code></pre></pre>
<!--notes
Pattern Matching
- What really makes Rust enums powerful
- Example 1
  - Extract data in your switch
- Example 2
  - Compile error when you miss one
  - No one can pull the rug out from under you!
- Example 3
  - wildcard matching for ignoring exhaustiveness
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#error-handling" id="error-handling">Error Handling</a></h1>
<pre><pre class="playpen"><code class="language-rust">fn main() -&gt; Result&lt;(), String&gt; {
    // question mark to short circut
    could_fail(1)?;
    // pattern matching
    match could_fail(2) {
        Ok(_) =&gt; (),
        Err(e) =&gt; eprintln!(&quot;{}&quot;, e),
    }
    // complains that result is unused
    could_fail(3);
    could_fail(5)
}

fn could_fail(n: u8) -&gt; Result&lt;(), String&gt; {
    if n % 2 == 0 {
        Err(format!(&quot;{} is even&quot;, n))
    } else {
        Ok(())
    }
}

</code></pre></pre>
<!--notes
Error Handling
- Enums + Pattern matching = beautiful error handling
- ? operator short circuts
- pattern matching on Ok vs Err
- warning when unused
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#user-defined-types" id="user-defined-types">User Defined Types</a></h1>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Thing {
    stuff: u8,
}

impl Thing {
    pub fn new() -&gt; Self {
        Self {
            stuff: 0,
        }
    }
    pub fn increment(&amp;mut self) {
        self.stuff += 1;
    }
    pub fn decrement(&amp;mut self) {
        self.stuff -= 1;
    }
    // private
    fn zero(&amp;mut self) {
        self.stuff = 0;
    }
    fn stuff(&amp;self) {
        self.stuff // copy
    }
    // consumes self
    fn inner(self) {
        self.stuff
    }
}
#}</code></pre></pre>
<!--notes
Object Oriented (sort of)
- Structs are Plain Old Objects
- `impl` for method defs
- Like python, self is first arg at def site
  - self = move
  - &self = reference
  - &mut self = mutable references
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#traits" id="traits">Traits</a></h1>
<!--web-only-->
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#implement-other-traits-for-your-type" id="implement-other-traits-for-your-type">Implement other traits for your type</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">#use std::fmt::{
#    Formatter,
#    Result,
#    Display,
#};
#enum Message {
#    Join(String),
#    Leave(String),
#    Nick(String, String),
#    Shout { from: String, msg: String},
#    Whisper {from: String, to: String, msg: String},
#    Kick(String),
#}
impl Display for Message {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result {
        match self {
            Message::Join(username) =&gt; {
                write!(f, &quot;👋 {} has joined the chat&quot;, username)
            },
            Message::Leave(username) =&gt; {
                write!(f, &quot;😢 {} has left the chat&quot;, username)
            },
            Message::Nick(from, to) =&gt; {
                write!(f, &quot;😎 {} has changed their username to {}&quot;, from, to)
            },
            Message::Shout { from, msg } =&gt; {
                write!(f, &quot;😃 {}: {}&quot;, from, msg)
            },
            Message::Whisper { from, to, msg } =&gt; {
                write!(f, &quot;🐱‍👤 secret message for {} from {}:\n    {}&quot;, to, from, msg)
            },
            Message::Kick(who) =&gt; {
                write!(f, &quot;👢 user {} has been kicked from the channel&quot;, who)
            },
        }
    }
}
fn main() {
    #    let messages = vec![
#        Message::Join(String::from(&quot;person1&quot;)),
#        Message::Join(String::from(&quot;person2&quot;)),
#        Message::Join(String::from(&quot;person3&quot;)),
#        Message::Nick(String::from(&quot;person2&quot;), String::from(&quot;JunkMaster3000&quot;)),
#        Message::Shout { 
#            from: String::from(&quot;JunkMaster3000&quot;), 
#            msg: String::from(&quot;All Hail JunkMaster!&quot;)
#        },
#        Message::Whisper {
#            from: String::from(&quot;person1&quot;),
#            to: String::from(&quot;person3&quot;),
#            msg: String::from(&quot;Whoa, that went in a different direction than I was expecting&quot;),
#        },
#        Message::Whisper {
#            from: String::from(&quot;person3&quot;),
#            to: String::from(&quot;person1&quot;),
#            msg: String::from(&quot;lol, yeah JunkMaster is a little wild sometimes&quot;),
#        },
#        Message::Leave(String::from(&quot;person1&quot;)),
#    ];
    //...
    for msg in messages {
        println!(&quot;{}&quot;, msg);
    }
}
</code></pre></pre>
<!--slides-only-->
<h3><a class="header" href="#implement-your-traits-for-other-types" id="implement-your-traits-for-other-types">Implement your traits for other types</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Firstable&lt;T&gt; {
    fn first(&amp;self) -&gt; &amp;T;
}
impl&lt;T&gt; Firstable&lt;T&gt; for Vec&lt;T&gt; {
    fn first(&amp;self) -&gt; &amp;T {
        &amp;self[0]
    }
}
impl&lt;T&gt; Firstable&lt;T&gt; for &amp;[T] {
    fn first(&amp;self) -&gt; &amp;T {
        &amp;self[0]
    }
}
#}</code></pre></pre>
<!--notes
Traits
- Primary method of shared behavior
- methods only
- can impl YOUR traits for OTHER's types
- can impl OTHER's traits for YOUR types
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#macros" id="macros">Macros</a></h1>
<!--web-only-->
<!--web-only-end-->
<!--slides-only-->
<h3><a class="header" href="#syntax-extensions-and-more" id="syntax-extensions-and-more">Syntax extensions and More</a></h3>
<!--slides-only-end-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;I'm a macro&quot;);
    println!(&quot;I'm from a custom derive: {:?}&quot;, Thing);
    println!(&quot;I'm from a an attribute macro: {}&quot;, say_hi());
}
#[derive(Debug)]
struct Thing;

#[inline]
fn say_hi() -&gt; &amp;'static str {
    &quot;Hello world!&quot;
}
</code></pre></pre>
<!--notes
Macros
- not going to be a long slide
- 4 kinds of macros
  - older macro_rules style
  - custom derives
  - attributes
  - function like macros
- Nearing finalization of hygiene
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#tests" id="tests">Tests</a></h1>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn add_one(v: u8) -&gt; u8 {
    v + 1
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_add_one() {
        assert_eq!(2, add_one(1));
        assert_eq!(3, add_one(2));
    }
}
#}</code></pre></pre>
<!--notes
Tests!
- Integrated test framework
- makes them first class concepts
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<ul>
<li>Rustup</li>
<li>Cargo</li>
<li>Project Types</li>
<li>The Standard Library</li>
</ul>
<!--notes
Getting Started
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#rustup" id="rustup">Rustup</a></h1>
<h2><a class="header" href="#environment-manager-for-rust" id="environment-manager-for-rust">Environment manager for rust</a></h2>
<h3><a class="header" href="#macoslinux" id="macoslinux">Macos/Linux</a></h3>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h3><a class="header" href="#windows" id="windows">Windows</a></h3>
<ol>
<li>Go to <a href="https://rustup.rs/">https://rustup.rs/</a></li>
<li>Download and install rustup-init.exe</li>
</ol>
<!--slides-only-->
<h2><a class="header" href="#contents" id="contents">Contents</a></h2>
<ol>
<li>Rustup</li>
<li>Cargo</li>
<li>Rustc</li>
</ol>
<!--slides-only-end-->
<h2><a class="header" href="#confirm-your-install" id="confirm-your-install">Confirm your install</a></h2>
<pre><code class="language-sh">rustc --version
cargo --version
rustup --version
</code></pre>
<!--notes
Rustup
- version manager for the compiler
- primary place to install
- installs 2 other items
  - rustc
  - cargo
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#cargo" id="cargo">Cargo</a></h1>
<p>The package manager and test runner and binary installer and build pipeline runner for most rust programs.</p>
<ul>
<li><code>cargo new</code></li>
<li><code>cargo init</code></li>
<li><code>cargo test</code></li>
<li><code>cargo run</code></li>
<li><code>cargo check</code></li>
<li><code>cargo install mdbook</code></li>
</ul>
<p><a href="https://crates.io">Crates.io</a></p>
<!--notes
Cargo
- Like NPM for "crates"
- Crates.io like npmjs.org
- Owned and operated by the community
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#bin-vs-lib" id="bin-vs-lib">Bin vs Lib</a></h1>
<h3><a class="header" href="#bin" id="bin">Bin</a></h3>
<ul>
<li>Must have main</li>
<li>Produces executable</li>
</ul>
<h3><a class="header" href="#lib" id="lib">Lib</a></h3>
<ul>
<li>Produces linkable library</li>
<li>A project can have many libs</li>
</ul>
<!--notes
Project Types
- Two major flavors
  - Lib = usable by others
  - Bin = executable
    - must export main/start point
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#std-types" id="std-types">Std Types</a></h1>
<h2><a class="header" href="#result" id="result"><code>Result</code></a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E)
}
#}</code></pre></pre>
<h2><a class="header" href="#option" id="option"><code>Option</code></a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<h2><a class="header" href="#string-vs-str" id="string-vs-str"><code>String</code> vs <code>&amp;str</code></a></h2>
<ul>
<li><code>String</code>: Heap allocated growable buffer</li>
<li><code>&amp;str</code>: Reference to fixed size buffer</li>
</ul>
<h2><a class="header" href="#vect-vs-t-n" id="vect-vs-t-n"><code>Vec&lt;T&gt;</code> vs <code>[T; N]</code></a></h2>
<ul>
<li><code>Vec</code>: Growable array (ArrayList/List)</li>
<li><code>[T; N]</code>: Fixed size array</li>
</ul>
<h2><a class="header" href="#boxt" id="boxt"><code>Box&lt;T&gt;</code></a></h2>
<ul>
<li>Heap allocated pointer</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">#fn main() {
let n = 100;
let heap_n = Box::new(n);
#}
</code></pre></pre>
<h2><a class="header" href="#numbers" id="numbers">Numbers</a></h2>
<ul>
<li><code>u8</code></li>
<li><code>i8</code></li>
<li><code>u16</code></li>
<li><code>i16</code></li>
<li><code>u32</code></li>
<li><code>i32</code></li>
<li><code>f32</code></li>
<li><code>u64</code></li>
<li><code>i64</code></li>
<li><code>f64</code></li>
<li><code>u128</code></li>
<li><code>i128</code></li>
<li><code>usize</code></li>
<li><code>isize</code></li>
</ul>
<h2><a class="header" href="#tuples" id="tuples">Tuples</a></h2>
<ul>
<li>First class data type</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">#fn main() {
let (x, y) = get_tuple();
#}
fn get_tuple() -&gt; (u8, u8) {
    (1, 2)
}
</code></pre></pre>
<!--notes
Std Types
- Result: error handling
- Option: Null Handler
- String vs &str
  - StringBuilder vs string (c#)
- Vec vs []
  - Array vs Array List
  - Vec: growable
  - []: static size
- Box:
  - Everything is stack allocated unless explicitly boxed
    - Some exceptions (String, Vec, HashMap...)
- Lots of numbers (all shapes and sizes)
  - usize & isize = size_t ish
- Loose data structures with strong typing
-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script><style>.presentation-only.not-presenting {
  display: none;
}

.article-content.presenting {
  display: none;
}

.notes-only {
  display: none;
}
</style>
<h1><a class="header" href="#resources" id="resources">Resources</a></h1>
<!--web-only-->
<ul>
<li><a href="https://doc.rust-lang.org/book/"><em>The</em> Book</a></li>
<li><a href="https://doc.rust-lang.org/std/index.html">std documentation</a></li>
<li><a href="https://github.com/rust-lang/rustlings/">rustlings</a></li>
<li><a href="https://docs.rs">docs.rs</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust By Example</a></li>
<li><a href="https://newrustacean.com/">New Rustacean</a></li>
<li><a href="https://cheats.rs/">Rust Language Cheat Sheet</a></li>
</ul>
<!--web-only-end-->
<!--slides-only-->
<ul>
<li><a href="https://doc.rust-lang.org/book/"><em>The</em> Book</a>
<ul>
<li>https://doc.rust-lang.org/book/</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/std/index.html">std documentation</a>
<ul>
<li>https://doc.rust-lang.org/std/index.html</li>
</ul>
</li>
<li><a href="https://github.com/rust-lang/rustlings/">rustlings</a>
<ul>
<li>https://github.com/rust-lang/rustlings/</li>
</ul>
</li>
<li><a href="https://docs.rs">docs.rs</a>
<ul>
<li>https://doc.rust-lang.org/stable/rust-by-example/</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust By Example</a>
<ul>
<li>(https://doc.rust-lang.org/stable/rust-by-example/</li>
</ul>
</li>
<li><a href="https://newrustacean.com/">New Rustacean</a>
<ul>
<li>https://newrustacean.com/</li>
</ul>
</li>
<li><a href="https://cheats.rs/">Rust Language Cheat Sheet</a>
<ul>
<li>https://cheats.rs/</li>
</ul>
</li>
</ul>
<!--slides-only-end-->
<script>var PresentationMode;
(function (PresentationMode) {
    PresentationMode[PresentationMode["Slides"] = 0] = "Slides";
    PresentationMode[PresentationMode["Web"] = 1] = "Web";
})(PresentationMode || (PresentationMode = {}));
var PresentationModeHider = (function () {
    function PresentationModeHider() {
        var _this = this;
        this.queryKey = 'presentation_mode';
        this.webClass = 'article-content';
        this.preClass = 'presentation-only';
        this.notesClass = 'notes-only';
        this.mode = this.getMode();
        this.setMode();
        this.assignClassesViaComments();
        if (this.mode === PresentationMode.Slides && (location.pathname === ''
            || location.pathname === '/')) {
            var chList = document.querySelector('.sidebar > .chapter');
            var firstLi = chList.firstChild;
            var firstLink = firstLi.firstChild;
            firstLink.click();
        }
        window.addEventListener('keyup', function (ev) {
            if (!ev.altKey)
                return;
            if (ev.key == 'p' || ev.key == 'P' || ev.code == 'KeyP') {
                _this.toggle();
            }
        });
    }
    PresentationModeHider.prototype.assignClassesViaComments = function () {
        var iter = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);
        var node;
        var modeClass = this.mode === PresentationMode.Web ? 'not-presenting' : 'presenting';
        var cls = null;
        while (node = iter.nextNode()) {
            if (node.nodeType === 8) {
                var value = node.nodeValue.trim();
                if (value === "web-only") {
                    cls = this.webClass;
                }
                else if (value === "slides-only") {
                    cls = this.preClass;
                }
                else if (value.startsWith('notes')) {
                    this.processNotes(value);
                }
                else if (value === "web-only-end"
                    || value === "slides-only-end"
                    || value === "notes-end") {
                    cls = null;
                }
            }
            else if (node.nodeType === 1 && cls !== null) {
                node.classList.add(cls, modeClass);
            }
        }
    };
    PresentationModeHider.prototype.getMode = function () {
        var mode = localStorage.getItem(this.queryKey);
        if (mode === null) {
            return PresentationMode.Web;
        }
        try {
            var ret = parseInt(mode);
            if (ret > 1 || ret < 0) {
                console.error('presentation_mode was out of range', ret);
                return PresentationMode.Web;
            }
            return ret;
        }
        catch (e) {
            console.error('presentation_mode present in localStorage but value is not an integer', mode, e);
            return PresentationMode.Web;
        }
    };
    PresentationModeHider.prototype.setMode = function () {
        localStorage.setItem(this.queryKey, this.mode.toString());
    };
    PresentationModeHider.prototype.updatePage = function () {
        this.updateElements(document.querySelectorAll('.presentation-only'));
        this.updateElements(document.querySelectorAll('.article-content'));
    };
    PresentationModeHider.prototype.updateElements = function (elements) {
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (this.mode === PresentationMode.Slides) {
                el.classList.replace('not-presenting', 'presenting');
            }
            else {
                el.classList.replace('presenting', 'not-presenting');
            }
        }
    };
    PresentationModeHider.prototype.toggle = function () {
        switch (this.mode) {
            case PresentationMode.Slides:
                this.mode = PresentationMode.Web;
                break;
            case PresentationMode.Web:
                this.mode = PresentationMode.Slides;
                break;
        }
        this.setMode();
        this.updatePage();
    };
    PresentationModeHider.prototype.processNotes = function (text) {
        var startIdx = text.indexOf('\n');
        console.log("%c" + text.substr(startIdx + 1), 'font-size: 14pt;');
    };
    return PresentationModeHider;
}());
var ___presentationModeHider = new PresentationModeHider();
</script>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="counter.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
